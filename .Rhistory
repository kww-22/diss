data_conds <- data.frame()
data_warm <- data.frame()
# iterate over data frames using row bind
for(i in 1:I(length(files)/2)){
data_new <- read.csv(str_glue(path,files[file_num_conds[i]], .sep = '/'))
data_conds <- rbind.data.frame(data_conds, data_new)
data_new <- read.csv(str_glue(path,files[file_num_warm[i]], .sep = '/'))
data_warm <- rbind.data.frame(data_warm, data_new)
}
data_conds <- write.csv(data_conds, str_glue(path, 'masters', 'data_conds.csv', .sep = '/'))
data_warm <- write.csv(data_warm, str_glue(path, 'masters', 'data_warm.csv', .sep = '/'))
}
get_velos()
# ----------------------------------------------------
# get_velos.R
#
# Purpose: to Import velos from data collection googlesheets
# and separate them by participant
#
# retrieves velos from googlesheet, cleans data frame
# and saves them to the 'velo_csvs' subfolder
#
# author: Kyle Wasserberger
#
# Last Updated: 2021-04-27
# ----------------------------------------------------
# library(googlesheets4)
# library(tidyverse)
get_velos <- function(){
require(googlesheets4)
require(tidyverse)
# edit url if you need to access different googlesheet
url <- 'https://docs.google.com/spreadsheets/d/1PRBYjZcG9b8jB1vttNicup2MhdabkgZY-tJQMLTPxKc/'
# get individual sheet info and subset out demos and template sheets
sheet_info <- gs4_get(url)
sheet_names <- sheet_info[["sheets"]][["name"]]
# all participant data sheets are "pXX" so they have a sheet name of length 3
p_sheets <- sheet_names[str_length(sheet_names) == 3]
sheets_final <- rev(select.list(p_sheets, multiple = TRUE, graphics = TRUE, preselect = p_sheets))
if(is_empty(sheets_final)){
stop('no sheets selected')
}
# get directory path for csv saving
path <- getwd()
# get demo info for level 2 vars
# filtering by pNums listed above
demos <- read_sheet(ss = url, sheet = 'Demos') %>%
filter(pNum %in% sheets_final)
# loops through saving each csvs for each sheet with custom titles based on sheet name
for(i in 1:length(sheets_final)){
# read everything on sheet i
data <- read_sheet(ss = url, sheet = sheets_final[i])
# select warmup throws, rename, and clean data
data_warmup <- data[-1,] %>%
select(c('Throw', 'Vel_warm'))
data_warmup <- data_warmup[1:demos$NumThrows[i],]
data_warmup <- rename(data_warmup,
velo = Vel_warm,
throw = Throw)
data_warmup$velo <- as.numeric(data_warmup$velo)
data_warmup <- mutate(data_warmup, pID = sheets_final[i],
velo_max = max(velo, na.rm = TRUE),
velo_min = min(velo, na.rm = TRUE),
height = demos$Height[i],
mass = demos$Weight[i],
age = demos$Age[i],
hand = factor(demos$Hand[i]))
data_warmup <- data_warmup[,c('pID','age', 'mass', 'height', 'hand', 'velo_max', 'velo_min', 'throw', 'velo')]
# select condition throws, rename, and clean data
data_conds <- data %>%
select(c('Effort', 'Cond1', 'Cond2', 'Vel_cons'))
data_conds <- data_conds[-which(is.na(data_conds$Cond1)),] %>%
mutate(pID = factor(sheets_final[i]),
Effort = factor(Effort, levels = c('50', '75', '100')),
Cond1 = factor(Cond1, levels = c('step', 'crow')),
Cond2 = factor(Cond2, levels = c('rpe','velo')))
# get condition df in same order as c3d files
data_conds <- data_conds %>%
rename(cond_stp = Cond1,
cond_int = Cond2,
velo = Vel_cons,
effort = Effort) %>%
arrange(pID,cond_int,effort,desc(cond_stp))
data_conds <- data_conds[,c('pID','cond_int','effort','cond_stp','velo')]
# create file names for csvs
file_name_warmup <- str_glue(path, '/sup/velo_csvs/', sheets_final[i],'_','velos_warmup.csv')
file_name_conds <- str_glue(path,'/sup/velo_csvs/',sheets_final[i], '_', 'velos_conds.csv')
write_csv(data_warmup, file_name_warmup)
write_csv(data_conds, file_name_conds)
# checks to make sure csv files exist in save directory
if(file.exists(file_name_conds) == TRUE & file.exists(file_name_warmup) == TRUE){
print(str_glue('velos extracted for ', sheets_final[i]))
}else{
stop('something went wrong, bro')
}
}
# get directory path and file info
path <- str_glue(getwd(),'sup/velo_csvs',.sep = '/')
files <- list.files(path = path, pattern = '_')
# create numeric vectors so for loops can separate warmup and condition velo files
file_num_conds <- seq(1,length(files),2)
file_num_warm <- seq(2,length(files),2)
# initialize blank data frames
data_conds <- data.frame()
data_warm <- data.frame()
# iterate over data frames using row bind
for(i in 1:I(length(files)/2)){
data_new <- read.csv(str_glue(path,files[file_num_conds[i]], .sep = '/'))
data_conds <- rbind.data.frame(data_conds, data_new)
data_new <- read.csv(str_glue(path,files[file_num_warm[i]], .sep = '/'))
data_warm <- rbind.data.frame(data_warm, data_new)
}
data_conds <- write.csv(data_conds, str_glue(path, 'masters', 'data_conds.csv', .sep = '/'))
data_warm <- write.csv(data_warm, str_glue(path, 'masters', 'data_warm.csv', .sep = '/'))
}
get_velos()
# ----------------------------------------------------
# get_velos.R
#
# Purpose: to Import velos from data collection googlesheets
# and separate them by participant
#
# retrieves velos from googlesheet, cleans data frame
# and saves them to the 'velo_csvs' subfolder
#
# compiles participant csvs into master csvs for warmup
# and condition throws
#
# author: Kyle Wasserberger
#
# Last Updated: 2021-04-27
# ----------------------------------------------------
# library(googlesheets4)
# library(tidyverse)
get_velos <- function(){
require(googlesheets4)
require(tidyverse)
# edit url if you need to access different googlesheet
url <- 'https://docs.google.com/spreadsheets/d/1PRBYjZcG9b8jB1vttNicup2MhdabkgZY-tJQMLTPxKc/'
# get individual sheet info and subset out demos and template sheets
sheet_info <- gs4_get(url)
sheet_names <- sheet_info[["sheets"]][["name"]]
# all participant data sheets are "pXX" so they have a sheet name of length 3
p_sheets <- sheet_names[str_length(sheet_names) == 3]
sheets_final <- rev(select.list(p_sheets, multiple = TRUE, graphics = TRUE, preselect = p_sheets))
if(is_empty(sheets_final)){
stop('no sheets selected')
}
# get directory path for csv saving
path <- getwd()
# get demo info for level 2 vars
# filtering by pNums listed above
demos <- read_sheet(ss = url, sheet = 'Demos') %>%
filter(pNum %in% sheets_final)
# loops through saving each csvs for each sheet with custom titles based on sheet name
for(i in 1:length(sheets_final)){
# read everything on sheet i
data <- read_sheet(ss = url, sheet = sheets_final[i])
# select warmup throws, rename, and clean data
data_warmup <- data[-1,] %>%
select(c('Throw', 'Vel_warm'))
data_warmup <- data_warmup[1:demos$NumThrows[i],]
data_warmup <- rename(data_warmup,
velo = Vel_warm,
throw = Throw)
data_warmup$velo <- as.numeric(data_warmup$velo)
data_warmup <- mutate(data_warmup, pID = sheets_final[i],
velo_max = max(velo, na.rm = TRUE),
velo_min = min(velo, na.rm = TRUE),
height = demos$Height[i],
mass = demos$Weight[i],
age = demos$Age[i],
hand = factor(demos$Hand[i]))
data_warmup <- data_warmup[,c('pID','age', 'mass', 'height', 'hand', 'velo_max', 'velo_min', 'throw', 'velo')]
# select condition throws, rename, and clean data
data_conds <- data %>%
select(c('Effort', 'Cond1', 'Cond2', 'Vel_cons'))
data_conds <- data_conds[-which(is.na(data_conds$Cond1)),] %>%
mutate(pID = factor(sheets_final[i]),
Effort = factor(Effort, levels = c('50', '75', '100')),
Cond1 = factor(Cond1, levels = c('step', 'crow')),
Cond2 = factor(Cond2, levels = c('rpe','velo')))
# get condition df in same order as c3d files
data_conds <- data_conds %>%
rename(cond_stp = Cond1,
cond_int = Cond2,
velo = Vel_cons,
effort = Effort) %>%
arrange(pID,cond_int,effort,desc(cond_stp))
data_conds <- data_conds[,c('pID','cond_int','effort','cond_stp','velo')]
# create file names for csvs
file_name_warmup <- str_glue(path, '/sup/velo_csvs/', sheets_final[i],'_','velos_warmup.csv')
file_name_conds <- str_glue(path,'/sup/velo_csvs/',sheets_final[i], '_', 'velos_conds.csv')
write_csv(data_warmup, file_name_warmup)
write_csv(data_conds, file_name_conds)
# checks to make sure csv files exist in save directory
if(file.exists(file_name_conds) == TRUE & file.exists(file_name_warmup) == TRUE){
print(str_glue('velos extracted for ', sheets_final[i]))
}else{
stop('something went wrong, bro')
}
}
# get directory path and file info
path <- str_glue(getwd(),'sup/velo_csvs',.sep = '/')
files <- list.files(path = path, pattern = '_')
# create numeric vectors so for loops can separate warmup and condition velo files
file_num_conds <- seq(1,length(files),2)
file_num_warm <- seq(2,length(files),2)
# initialize blank data frames
data_conds <- data.frame()
data_warm <- data.frame()
# iterate over data frames using row bind
for(i in 1:I(length(files)/2)){
data_new <- read.csv(str_glue(path,files[file_num_conds[i]], .sep = '/'))
data_conds <- rbind.data.frame(data_conds, data_new)
data_new <- read.csv(str_glue(path,files[file_num_warm[i]], .sep = '/'))
data_warm <- rbind.data.frame(data_warm, data_new)
}
data_conds <- write.csv(data_conds, str_glue(path, 'masters', 'data_conds.csv', .sep = '/'))
data_warm <- write.csv(data_warm, str_glue(path, 'masters', 'data_warm.csv', .sep = '/'))
}
get_velos()
# ----------------------------------------------------
# get_velos.R
#
# Purpose: to Import velos from data collection googlesheets
# and separate them by participant
#
# retrieves velos from googlesheet, cleans data frame
# and saves them to the 'velo_csvs' subfolder
#
# compiles participant csvs into master csvs for warmup
# and condition throws
#
# author: Kyle Wasserberger
#
# Last Updated: 2021-04-27
# ----------------------------------------------------
# library(googlesheets4)
# library(tidyverse)
get_velos <- function(){
require(googlesheets4)
require(tidyverse)
# edit url if you need to access different googlesheet
url <- 'https://docs.google.com/spreadsheets/d/1PRBYjZcG9b8jB1vttNicup2MhdabkgZY-tJQMLTPxKc/'
# get individual sheet info and subset out demos and template sheets
sheet_info <- gs4_get(url)
sheet_names <- sheet_info[["sheets"]][["name"]]
# all participant data sheets are "pXX" so they have a sheet name of length 3
p_sheets <- sheet_names[str_length(sheet_names) == 3]
sheets_final <- rev(select.list(p_sheets, multiple = TRUE, graphics = TRUE, preselect = p_sheets))
if(is_empty(sheets_final)){
stop('no sheets selected')
}
# get directory path for csv saving
path <- getwd()
# get demo info for level 2 vars
# filtering by pNums listed above
demos <- read_sheet(ss = url, sheet = 'Demos') %>%
filter(pNum %in% sheets_final)
# loops through saving each csvs for each sheet with custom titles based on sheet name
for(i in 1:length(sheets_final)){
# read everything on sheet i
data <- read_sheet(ss = url, sheet = sheets_final[i])
# select warmup throws, rename, and clean data
data_warmup <- data[-1,] %>%
select(c('Throw', 'Vel_warm'))
data_warmup <- data_warmup[1:demos$NumThrows[i],]
data_warmup <- rename(data_warmup,
velo = Vel_warm,
throw = Throw)
data_warmup$velo <- as.numeric(data_warmup$velo)
data_warmup <- mutate(data_warmup, pID = sheets_final[i],
velo_max = max(velo, na.rm = TRUE),
velo_min = min(velo, na.rm = TRUE),
height = demos$Height[i],
mass = demos$Weight[i],
age = demos$Age[i],
hand = factor(demos$Hand[i]))
data_warmup <- data_warmup[,c('pID','age', 'mass', 'height', 'hand', 'velo_max', 'velo_min', 'throw', 'velo')]
# select condition throws, rename, and clean data
data_conds <- data %>%
select(c('Effort', 'Cond1', 'Cond2', 'Vel_cons'))
data_conds <- data_conds[-which(is.na(data_conds$Cond1)),] %>%
mutate(pID = factor(sheets_final[i]),
Effort = factor(Effort, levels = c('50', '75', '100')),
Cond1 = factor(Cond1, levels = c('step', 'crow')),
Cond2 = factor(Cond2, levels = c('rpe','velo')))
# get condition df in same order as c3d files
data_conds <- data_conds %>%
rename(cond_stp = Cond1,
cond_int = Cond2,
velo = Vel_cons,
effort = Effort) %>%
arrange(pID,cond_int,effort,desc(cond_stp))
data_conds <- data_conds[,c('pID','cond_int','effort','cond_stp','velo')]
# create file names for csvs
file_name_warmup <- str_glue(path, '/sup/velo_csvs/', sheets_final[i],'_','velos_warmup.csv')
file_name_conds <- str_glue(path,'/sup/velo_csvs/',sheets_final[i], '_', 'velos_conds.csv')
write_csv(data_warmup, file_name_warmup)
write_csv(data_conds, file_name_conds)
# checks to make sure csv files exist in save directory
if(file.exists(file_name_conds) == TRUE & file.exists(file_name_warmup) == TRUE){
print(str_glue('velos extracted for ', sheets_final[i]))
}else{
stop('something went wrong, bro')
}
}
# get directory path and file info
path <- str_glue(getwd(),'sup/velo_csvs',.sep = '/')
files <- list.files(path = path, pattern = '_')
# create numeric vectors so for loops can separate warmup and condition velo files
file_num_conds <- seq(1,length(files),2)
file_num_warm <- seq(2,length(files),2)
# initialize blank data frames
data_conds <- data.frame()
data_warm <- data.frame()
# iterate over data frames using row bind
for(i in 1:I(length(files)/2)){
data_new <- read.csv(str_glue(path,files[file_num_conds[i]], .sep = '/'))
data_conds <- rbind.data.frame(data_conds, data_new)
data_new <- read.csv(str_glue(path,files[file_num_warm[i]], .sep = '/'))
data_warm <- rbind.data.frame(data_warm, data_new)
}
data_conds <- write.csv(data_conds, str_glue(path, 'masters', 'data_conds.csv', .sep = '/'))
data_warm <- write.csv(data_warm, str_glue(path, 'masters', 'data_warm.csv', .sep = '/'))
}
get_velos()
library(readr)
data_warm <- read_csv("sup/velo_csvs/masters/data_warm.csv")
View(data_warm)
data_warm <- data_warm[,-1]
library(readr)
data_warm <- read.csv("sup/velo_csvs/masters/data_warm.csv", stringsAsFactors = TRUE)
data_warm <- data_warm[,-1]
unique(data_warm$velo_max)
hist(unique(data_warm$velo_max))
library(tidyverse)
path <- getwd()
d <- read.csv("sup/velo_csvs/masters/data_warm.csv", stringsAsFactors = T)
ggplot(data = d, aes(x = throw, y = velo, color = pID)) +
geom_path(size = 1, show.legend = T) +
geom_point(size = 2, show.legend = F) +
theme_bw() +
theme(aspect.ratio = 1,
axis.text = element_text(size = 16),
axis.title = element_text(size = 16))
ggplot(data = d, aes(x = throw, y = velo, color = pID)) +
geom_path(size = 1, show.legend = F) +
geom_point(size = 2, show.legend = F) +
theme_bw() +
theme(aspect.ratio = 1,
axis.text = element_text(size = 16),
axis.title = element_text(size = 16))
View(data_warm)
get_velos()
library(readr)
data_warm <- read_csv("sup/velo_csvs/masters/data_warm.csv")
install.packages(c("gargle", "interactions", "Rcpp"))
library(lme4)
library(lmerTest)
please_work <- read.csv("~/GitHub/diss/data/please_work.csv", stringsAsFactors = T)
m0 <- lmer(velo ~ 1 + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
summary(m0)
icc(m0)
performance::icc(m0)
library(performance)
mICC <- icc(m0)
mICC <- icc(m0)[1]
mICC <- icc(m0)[[1]]
m1 <- lmer(velo ~ elb_var + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m2 <- lmer(velo ~ elb_var + I(elb_var^2/100) + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m3 <- lmer(velo ~ elb_var + I(elb_var^2/100) + (1+elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m4 <- lmer(velo ~ elb_var + log(elb_var) + (elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m1,m2, m3,m4), digits = 4, single.row = T,
custom.model.names = c("Rand Int","Poly","Poly + RS","Log"))
library(texreg)
screenreg(list(m1,m2, m3,m4), digits = 4, single.row = T,
custom.model.names = c("Rand Int","Poly","Poly + RS","Log"))
m2 <- lmer(velo ~ elb_var + I(elb_var^2) + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m1,m2, m3,m4), digits = 4, single.row = T,
custom.model.names = c("Rand Int","Poly","Poly + RS","Log"))
b1_min <- fixef(m3)[[2]]+min(ranef(m3)[[1]][2])
b1_max <- fixef(m3)[[2]]+max(ranef(m3)[[1]][2])
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m4 <- lmer(velo ~ elb_var + log(elb_var) + (elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
install.packages("nonnest2", dependencies = T)
library(nonnest2)
?vuongtest
vuongtest(m3,m4)
vuongtest(m3,m4, nested = F, adj = "none")
library(lavaan)
?lavaan
m3 <- lmer(velo ~ 0 + elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m4 <- lmer(velo ~ 0 + elb_var + log(elb_var) + (elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m1,m2, m3,m4), digits = 4, single.row = T,
custom.model.names = c("Rand Int","Poly","Poly + RS","Log"))
m1 <- lmer(velo ~ elb_var + (1|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m2 <- lmer(velo ~ elb_var + I(elb_var^2) + (1|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m4 <- lmer(velo ~ elb_var + log(elb_var) + (elb_var|pID), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m1,m2, m3,m4), digits = 4, single.row = T,
custom.model.names = c("Rand Int","Poly","Poly + RS","Log"))
performance(list(m3,m4))
performance(m3,m4
)
performance_lrt(m3,m4)
sigma(m3)
sigma(m4)
Metrics::mae(m3)
Metrics::mae(actual = please_work$velo, predicted = predict(m3))
predict(m3)
length(predict(m3))
length(please_work$velo, na.rm = T)
length(please_work$velo)
mean(abs(resid(m3)))
mean(abs(resid(m4)))
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (elb_var|mass), data = please_work,
REML = F, control = lmerControl(optimizer = "Nelder_Mead"))
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), single.row = T)
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m1 <- lmer(velo ~ elb_var + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m2 <- lmer(velo ~ elb_var + I(elb_var^2) + (1|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (1+elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m4 <- lmer(velo ~ elb_var + log(elb_var) + (elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), single.row = T)
screenreg(list(m3, m5), digits = 4, single.row = T)
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID+mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), digits = 4, single.row = T)
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (0+elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
m3 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), digits = 4, single.row = T)
var(ranef(m3))
ranef(m3)
ranef(m3)[[2]]
ranef(m3)[[1]][2]
var(ranef(m3)[[1]][2])
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|pID) + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), digits = 4, single.row = T)
summary(m5)
ranef(m5)
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
ranef(m5)
summary(m5)
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + elb_var:mass + (elb_var|mass), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
summary(m5)
m5 <- lmer(velo ~ elb_var + I(elb_var^2) + mass+ (elb_var|pID), data = please_work,
REML = T, control = lmerControl(optimizer = "Nelder_Mead"))
screenreg(list(m3, m5), digits = 4, single.row = T)
fixef(m3)+ranef(m3)
fixef(m3)[[1]][2]+ranef(m3)[[1]][2]
fixef(m3)[[1]][2]
fixef(m3)[[1]]
fixef(m3)
fixef(m3)[[1]][2]
fixef(m3)[[2]]
fixef(m3)[[2]]+ranef(m3)[[1]][2]
mean(fixef(m3)[[2]]+ranef(m3)[[1]][2])
total_effects <- fixef(m3)[[2]]+ranef(m3)[[1]][2]
total_effects[1]
total_effects[[1]]
mean(total_effects[[1]])
unique(please_work$mass)
table(please_work$mass)
library(tidyverse)
test <- please_work %>% group_by(pID) %>%
summarise()
View(test)
test <- please_work %>% group_by(pID) %>%
summarise(mass)
View(test)
test <- please_work %>% aggregate(pID) %>%
summarise(mass)
test <- please_work %>% aggregate(pID, FUN = "mean") %>%
summarise(mass)
test <- please_work %>% aggregate("pID", FUN = "mean")
test <- please_work %>% aggregate(list("pID"), FUN = "mean")
test <- please_work %>% aggregate(list(pID, mass), FUN = "mean")
test <- please_work %>% aggregate(list("pID", "mass"), FUN = "mean")
